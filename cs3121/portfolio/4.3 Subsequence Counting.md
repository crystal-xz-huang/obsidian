# 4.3 \[PS\] Subsequence Counting

![[COMP3121_9101-4.3.pdf#height=800]]

Related to:

- [[Longest Common Subsequence|Longest Common Subsequence (LCS)]]

Similar Problems:
- [Distinct Subsequences - LeetCode](https://leetcode.com/problems/distinct-subsequences/editorial/)

---

## Problem Description

> [!problem|blue no-icon] Subsequence Counting
> Suppose that Alice has a favourite string ==$A = a_1 \ldots a_n$ of length $n$== and Bob has a favourite string ==$B = b_1 \ldots b_m$ of length $m$.== Alice argues that Bob copied her string but changed some of the letters in between. Alice is curious about the number of ways Bob could have done this. That is, Alice wants to count the number of times $A$ appears as a subsequence $B$. 
> 
> Design an algorithm that runs in ==$O(nm)$== time to count the number of occurrences of $A$ as a subsequence of $B$.

> [!abstraction]
> <b>Instance</b>: 
> Two strings $A = a_1 \ldots a_n$ (of length $n$) and $B = b_1 \ldots b_m$ (of length $m$). 
> 
> <b>Task</b>: 
> Count the number of occurrences of $A$ as a [[Sequences#Definitions#Subsequences|subsequence]] of $B$.
> Return the number of distinct subsequences of $B$ which equal to $A$.
> 
> **Constraints:**
> ==$n \leq m$== for all $n$ characters of A to occur at least once in B

- How many distinct ways can you generate $A$ from $B$?
- $A$ occurs in $B$ if there is a subsequence of $B$ equal to $A$. 

## Definitions and Notations

> [!definition]
> We say that **$A$ is a subsequence of $B$** if there exists a strictly increasing length-$n$ sequence of indices of $B$ 
>
> $$
> 1 \le i_1 < i_2 < \cdots < i_n \le m
> $$
>
> such that 
>
> $$
> a_j = b_{i_j} \quad \text{for all } j = 1, 2, \dots, n.
> $$
>
> Equivalently, we can write:
>
> $$
> A = b_{i_1} b_{i_2} \ldots b_{i_n} \text{ for some } 1 ≤ i_1 < i_2 < \cdots < i_n ≤ m.
> $$

---

The **subsequence of $B$** corresponding to those indices is written as:

$$
B' = b_{i_1} b_{i_2} \cdots b_{i_n}.
$$

Then, the condition “the subsequence of $B$ equals $A$” is simply:

$$
A = B' = b_{i_1} b_{i_2} \cdots b_{i_n}.
$$

---

A concise way to write this relationship is:

$$
\exists\, 1 \le i_1 < i_2 < \cdots < i_n \le m \text{ such that } A = b_{i_1} b_{i_2} \cdots b_{i_n}.
$$

or equivalently,

$$
A = B[i_1, i_2, \dots, i_n],
$$

where $B[i_1, i_2, \dots, i_n]$ denotes the subsequence of $B$ formed by those positions.

---

## Dynamic Programming Solution

<b>Subproblems:</b>  

> Constraint: $1 \leq n \leq m$ for $A$ of length $n$ to occur in $B$ of length $m$.

For $1 \le i \leq n, \ 1 \leq j \le m$, let $\operatorname{SubCount}(i,j)$ be the number of occurrences of $A[1..i]$ as a subsequence of $B[1..j]$.

- The base case occurs at $i = 0$ with  $\operatorname{SubCount}(0,j)=1$
- The base case occurs at $j = 0$ with  $\operatorname{SubCount}(0,j)=1$

<b>Recurrence:</b>  
For $0<i,j \leq m$,

$$
\operatorname{SubCount}(i,j)=
\begin{cases}
\operatorname{SubCount}(i, j-1) & \text{if } a_i \ne b_j,\\[4pt]
\operatorname{SubCount}(i, j-1) + \operatorname{SubCount}(i-1, j-1) & \text{if } a_i = b_j.
\end{cases}
$$

<b>Base cases:</b>  
1. $\operatorname{SubCount}(0,j)=1$ for all $0 \le j \le m$ (empty string $A$ is a subsequence of every string)
2. $\operatorname{SubCount}(i,0)=0$ for all $1 \le i \le n$ (non-empty $A$ cannot occur in an empty $B$; note that if $i = 0$, then we have the base case above).

<b>Order of computation:</b>  
Fill a $(n{+}1)\times(m{+}1)$ table in lexicographic order of $(i,j)$ (increasing $i$, then increasing $j$), so that $\operatorname{opt}(i, j-1)$ and $\operatorname{opt}(i-1, j-1)$ are available when computing $\operatorname{opt}(i,j)$.

<b>Overall answer:</b> 
$\operatorname{opt}(n,m)$.

<b>Time complexity:</b> 
$O(nm)$ subproblems each taking $O(1)$ time to solve. 
Therefore the total running time is $\Rightarrow O(nm)$.


For all $0 \leq i \leq n$ and $0 \leq j \leq m$, let $\operatorname{opt}(i,j)$ denote the number of occurrences of $A[1..i]$ as a subsequence of $B[1..j]$.

We can choose to either include the $i$th element or exclude it from our set. We consider these two scenarios separately.

We can get the number of occurrences of from any of the previous trading posts. T

## Developing the Solution

> [!problem]
> Given two strings $s$ and $t$, return the number of distinct subsequences of $s$ which equals $t$.

#### Optimal Substructure

> [!check] Optimal Substructure
> The problem of counting the number of times $A[1..i]$ occurs as a subsequence of $B[1..j]$ has optimal substructure because any occurrence of $A[1..i]$ in $B[1..j]$ either
> 
> - does *not* include $b_j$, in which case it is an occurrence of $A[1..i]$ in $B[1..j-1]$, or
> - does includes $b_j = a_i$, in which case it is formed by appending $b_j$ to an occurrence of $A[1..i-1]$ in $B[1..j-1]$. 
> 
> Thus, the total number of occurrences at $(i,j)$ can be obtained by combining solutions to these two smaller subproblems.

> [!check] Optimal Substructure #2
> The set of all subsequences of $B[1..j]$ that equal $A[1..i]$ can be partitioned into two disjoint subsets:
> 
> 1. Those that use $b_j$ 
> 2. Those that do not use $b_j$ 
> 
> The first subset is exactly the set of subsequences of $B[1..j-1]$ that equal to $A[1..i]$.
> The second subset is set of subsequences of $B[1..j-1]$ that equal to $A[1..i-1]$, extended by $b_j$. 
> 
> These two subsets are disjoint and together form all possible subsequences of $B[1..j]$ that equal to $A[1..i]$.

#### Recursive Solution

The number of distinct subsequences of an n-long string x can be computed with Θ(n) arithmetic operations as follows: when we elongate the prefix $x_n$ that does not yet occur in $x_{n-1}$


**Subproblems**

Let $\operatorname{opt}(i,j)$ be the number of occurrences of $A[1..i]$ as a subsequence of $B[1..j]$.
%% Let $\operatorname{opt}(i,j)$ be the number of distinct subsequences of $A[1..i]$ which equals $B[1..j]$.
Let $\operatorname{opt}(i,j)$ be the number of ways the prefix $A[1..i]$ occurs as a subsequence of $B[1..j]$. %%

Solve the subproblem "find the number of ways a prefix of $A$ occurs as a subsequence of $B$" for all *pairs of prefixes* $(i, j)$ for $0 \leq i \leq n$ and $0 \leq j \leq m$.

Suppose we have an optimal solution for $\operatorname{opt}(i,j)$. 
How can we solve for $\operatorname{opt}(i,j)$ in terms of the smaller problems?

**Steps**
Take prefixes of both sequences and consider the last characters: if it matches then the optimal solution can either take it or discard it. Take the sum of both options. 

> We need to keep in mind that A is fixed subsequence and B the longer subsequence from which we want to derive A.

> Note: Every $a_i$ must be matched with an identical letter in B in the optimal solutions.

1. Case 1: Last characters do not match $a_i \neq b_j$. 
	- If there is a mismatch then$a_i$ must have been matched with some previous letter in $B$ so we move forward in string $B$.
	- $\operatorname{opt}(i,j) = \operatorname{opt}(i, j-1)$
2. Case 2: Last characters match up $a_i = b_j$ 
	1. The optimal solution can either include $b_j$ as a match for $a_i$ at this point or discard $b_j$ for some earlier/previous match in B with $a_i$.
	2. If it does use this match then we have $\operatorname{opt}(i-1, j-1)$ ways to place the remaining $i-1$ letters, 
	3. If it skips this match then match $a_i$ with the prefix of B so $\operatorname{opt}(i, j-1)$

Case 1: If $a_i \neq b_j$ then

$$\operatorname{opt}(i,j) = \operatorname{opt}(i, j-1)$$

Case 2: If $a_i \neq b_j$ then

$$\operatorname{opt}(i,j) = \operatorname{opt}(i, j-1) + \operatorname{opt}(i-1, j-1) $$

**Basis**
If A is empty ($i = 0$) the problem is trivial because an empty string is a subsequence of any string. If B is empty ($j = 0$) but A is not ($i > 0$) there are still characters to be matched in A, so clearly A does not occur in B. 

- $\operatorname{opt}(0,j) = 1$ for all $j \in \{0,\ldots,m \}$ (empty A occurs once in B).
- $\operatorname{opt}(i, 0) = 0)$ for all $i \in \{ 1,\ldots,n \}$ (nonempty A cannot occur in an empty B)

**Recurrence**

For all $i, j > 0$:

$$
\operatorname{opt}(i,j) =
\begin{cases}
\operatorname{opt}(i, j-1) & \text{if } a_i \ne b_j\\[4pt]
\operatorname{opt}(i, j-1) + \operatorname{opt}(i-1, j-1) & \text{if } a_i = b_j
\end{cases}
$$

**Dependencies**
- To compute $\operatorname{opt}(i,j)$ we must have already solved for $\operatorname{opt}(i, j-1)$ and $\operatorname{opt}(i-1, j-1)$.
- Solve in increasing order of $i=0..n$ and then $j=0..m$ (**lexicological order**) 

**Complexity**
- $O(n \times m)$ (one constant-time update per table entry)

## Proof


To formally prove the above, it helps to introduce, as we have done for optimization problems, the notation $\operatorname{Cand}(m)$ to be the set of all increasing subsequences of $A[1 : m]$ which end with $A[m]$. Therefore,
$$
\operatorname{LIS}(m) = \max_{\sigma \in \operatorname{Cand}(m)} |\sigma|.
$$

**(≥)**  
Fix any $1 \le j < m$ with $A[j] \le A[m]$, and let $\sigma'$ be the LIS of $A[1 : j]$ ending with $A[j]$ of length $\operatorname{LIS}(j)$.  
Then $\sigma = \sigma' \circ A[m]$ is in $\operatorname{Cand}(m)$ and has length $1 + \operatorname{LIS}(j)$.  
Hence,
$$
\operatorname{LIS}(m) \ge 1 + \operatorname{LIS}(j).
$$

**(≤)**  
Fix the sequence $\sigma \in \operatorname{Cand}(m)$ of length $\operatorname{LIS}(m)$.  
If $|\sigma| = 1$, then the inequality is vacuous.  
Otherwise, let $A[j]$ be the second-last entry of $\sigma$.  
Note that $\sigma' = \sigma - A[m]$ is in $\operatorname{Cand}(j)$ and has length $\operatorname{LIS}(m) - 1$.  
Therefore,
$$
\operatorname{LIS}(j) \ge |\sigma'| = \operatorname{LIS}(m) - 1,
$$
which implies
$$
\operatorname{LIS}(m) \le 1 + \operatorname{LIS}(j).
$$

- let $\operatorname{SubCount}(i,j)$ be the number of occurrences of $A[1..i]$ as a subsequence of $B[1..j]$, is equivalent to

**Formal Proof**
When $i=0$, the problem is trivial; an empty string is a subsequence of every string. Therefore, $\prob{SubCount}(0,j) = 1$. When $j=0$, there is no possibility of a match in an empty string; thus $\prob{SubCount}(i, 0) = 0$.     
    
For $i, j \geq 1$, assume that all previous subproblems have been solved correctly. Firstly, we note that when $i > j$, there are not enough characters in $B$ to match the ones in $A$, so the count must be $0$ in this case. Without loss of generality, we may assume that $i \leq j$. 

Now consider any occurrence of $A[1..i]$ as a subsequence of $B[1..j]$. Note that the last two characters $a_i$ and $b_i$ either match or do not match. 

- Case 1. If $a_i \ne b_j$, then it must be the case that the $A[1..i]$ occurs in the prefix $B[1..j-1]$. By the inductive hypothesis, there are $\operatorname{SubCount}(i,j-1)$ such subsequences when $a_i = b_j$.
- Case 2. If $a_i = b_j$, then any occurrence of $A[1..j]$ in $B[1..j]$ either includes $b_j$ or not include $b_j$. We consider both subcases.
	- If it does include $b_j$, then removing this last match gives any occurrence of  $A[1..i-1]$ in $B[1..j-1]$. Therefore, each of these subsequences can be extended to be a subsequence in $B[1..j]$ equal to $A[1..i]$ by appending $a_i=b_j$ to the end. In this case, there are $\operatorname{SubCount}(i-1,j-1)$ number such subsequences.
	- If it does not include $b_j$, then $A[1..i-1]$ must occur entirely within $B[1..j-1]$, giving $\operatorname{SubCount}(i,j-1)$ number of such subsequences.
	- These two sets are disjoint and exhaustive; thus the sum $\operatorname{SubCount}(i,j-1) + \operatorname{SubCount}(i-1,j-1)$ gives the number of occurrences of $A[1..j]$ in $B[1..j]$ when $a_i = b_j$.

In all, these cases consider all possible occurrences of $A$ in $B$, which proves the correctness of the recurrence.

## Implementation

```python
def numDistinct(self, s: str, t: str) -> int:

	M: int = len(s)
	N: int = len(t)

	# Dynamic Programming table
	dp: List[List[int]] = [[0 for _ in range(N + 1)] for _ in range(M + 1)]

	# Base case initialization
	for j in range(N + 1):
		dp[M][j] = 0

	# Base case initialization
	for i in range(M + 1):
		dp[i][N] = 1

	# Iterate over the strings in reverse so as to
	# satisfy the way we've modeled our recursive solution
	for i in range(M - 1, -1, -1):
		for j in range(N - 1, -1, -1):

			# Remember, we always need this result
			dp[i][j] = dp[i + 1][j]

			# If the characters match, we add the
			# result of the next recursion call (in this
			# case, the value of a cell in the dp table)
			if s[i] == t[j]:
				dp[i][j] += dp[i + 1][j + 1]

	return dp[0][0]
```


## Similar: Distinct Subsequences

Let $s_1, \ldots, s_n$ be the elements of $S$ (in order of appearance). Let $S[1\ldots k]$ denote the partial sequence $s_1, \ldots, s_k$. Let $a_k$ be the number of **distinct** subsequences of $S[1\ldots k]$, and suppose we already have calculated the values of $a_0, a_1, a_2, \ldots, a_{n-1}$ (note that $a_0 = 1$ for the trivial subsequence).

 - If $s_n$ is different from all elements of $S\setminus \{s_n\}$, then
   easily $a_n = 2 a_{n-1},$ since to get a subsequence of $S$ we
   either append $s_n$ to a subsequence of $S[1\ldots n-1]$ or we leave
   it as-is. There are no duplicates within the first category or
   within the second category, and there is no intersection between the
   two since any subsequence containing $s_n$ cannot be a subsequence of

   $S[1\ldots n-1]$. Hence in this case, $$a_n = 2a_{n-1}.$$

 - If $s_n$ is equal to some previous $s_j$ with $j<n$, then we will
   have a non-trivial intersection, as exist some subsequences of
   $S[1\ldots n-1]$ that remain subsequences of $S[1\ldots n-1]$
   after we append $s_n$. Still, we only need to count the number of
   such redundancies.

   Let $j$ be the highest index $j<n$ such that $s_j = s_n$. Then any subsequence of $S[1\ldots n-1]$ that ends in $s_n$ must be a subsequence of $S[1\ldots j]$. In fact the number of (distinct) such subsequences is exactly $a_{j-1}$: for any subsequence of $S[1\ldots j-1]$, appending $s_j$ gives a subsequence of $S[1\ldots n-1]$. So we overcount by exactly $a_{j-1}$, which means that

$$a_n = 2a_{n-1} - a_{j-1}.$$

Let's work out this for your example $\{1,2,2,1\}$:

$$\begin{align}
a_0 &= 1, \\
a_1 &= 2 a_0 = 2, &\text{(first case)} \\
a_2 &= 2 a_1 = 4, &\text{(first case)} \\
a_3 &= 2 a_2 - a_1 = 6, &(s_3 = s_2) \\
a_4 &= 2 a_3 - a_0 = 11. &(s_4 = s_1)
\end{align}$$

It is relatively easy to turn this into a linear time algorithm (assuming that arithmetic is constant-time, which can be a strong assumption for an exponentially growing sequence), as the search for the highest matching index can be done very efficiently with hash tables.

- [combinatorics - Number of distinct subSEQUENCES to a set that has repeated values - Mathematics Stack Exchange](https://math.stackexchange.com/questions/4136996/number-of-distinct-subsequences-to-a-set-that-has-repeated-values)

