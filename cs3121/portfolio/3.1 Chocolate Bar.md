![[COMP3121_9101-3.1.pdf#height=800]]

# Notes

> In the example, A is the same array as T

Each happy child receives a segment (non-overlapping subarray) s.t. the sum of `T[i] ≥ k`  

$$\sum_{p=i}^{j} T[p]  \geq k.$$

## Abstraction

> [!example|style-ad] Abstraction
> Given an array `T` of length `n` and an integer `k`, return _the maximum number of (**non-empty**) **non-overlapping** subarrays such that the sum of values in each subarray is greater than or equal to_ `k`.

It can be proved that greedily forming valid subarrays as soon as one is found is optimal.

Implementation:
1. Initialise `count` to 0 and `current_sum` to 0.
2. Iterate through each number in `T`:
	1. Add the number to `current_sum`.
	2. If `current_sum` is greater than or equal to `k`:
		1. Increment `count` and reset `current_sum` to 0.
3. Return count.

```python
def maxNonOverlapping(self, nums: List[int], target: int) -> int:
	count = 0
	current_sum = 0

	# Iterate through the array
	for num in nums:
		# Update the current sum
		current_sum += num

		# Check if the current sum is greater than or equal to target
		if current_sum >= target:
			count += 1
			current_sum = 0

	return count
	
# Time Complexity: O(n)
# Space Complexity: O(1)
```

# Solution

Let `T` be the array of pieces in the chocolate bar, where each piece `i` has `T[i]` nougats.
We say a segment is valid if the sum of all pieces is greater than or equal to `k`. 

The greedy choice is to always take the earliest subarray that meets the condition. 
The reason this works is that by taking the earliest valid subarray, we leave as much room as possible for future subarrays, maximising the total count of non-overlapping subarrays.
This approach ensures that we are always making the optimal choice at each step, leading to a globally optimal solution.

The greedy algorithm works as follow: 

- First, we initialise a counter to keep track of the number of valid subarrays found, and a variable to maintain the current sum of the subarray being considered. We then iterate through the array, adding each element to the current sum. Whenever the current sum meets or exceeds the target value k, we increment our counter and reset the current sum to zero, effectively starting a new subarray from the next element. This process continues until we have traversed the entire array. By always choosing to end a subarray as soon as it meets the target, we ensure that we maximize the number of non-overlapping subarrays.
- Starting from an empty segment and a count of zero, we add pieces of the chocolate bar to the current segment one by one, keeping track of the total number of nougat clumps. Whenever the total number of nougat clumps in the current segment reaches or exceeds $k$, we can finalise that segment, increment the count of happy children, and start a new segment from the next piece of the bar. Continue this process until all pieces of the Toblerone bar have been considered. At the end, the count will represent the maximum number of happy children. This ensures that we maximize the number of happy children by always forming the smallest possible segment that meets the requirement, allowing for more segments to be formed from the remaining pieces of the bar.

# References & Further Reading

- [Maximum Number of Non-Overlapping Subarrays With Sum Equals Target - LeetCode](https://leetcode.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/description/)