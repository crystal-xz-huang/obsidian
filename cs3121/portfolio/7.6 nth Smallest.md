---
aliases:
  - Median of Two Sorted Arrays
tags:
  - topic/binary-search
  - topic/divide-and-conquer
cssclasses:
  - img-grid
---

# 7.6 nth Smallest

![[COMP3121_9101-7.6.pdf#height=400]]

## Problem Description

> [!problem]
> Let $A[1..n]$ and $B[1..n]$ be two sorted arrays each containing $n$ distinct integers, and $A$ and $B$ have no elements in common. You may assume that $n$ is a power of two, say $2^\ell$. Describe a $O(\log n)$ algorithm that finds the $n$th smallest element of $A ∪ B$ (where $A ∪ B$ is the array obtained by merging $A$ and $B$ together).

> [!observation]
> The $n$th smallest element in the combined array of size $2n$ is the **median** of the two arrays. Median = $(n + n) / 2 = 2n / 2 = n$.

Observations:
- Consider the two sorted arrays $A$ and $B$, both of size $n$.
- The union of $A$ and $B$ is an array of size $2n$. 
- In the sorted $A\cup B$, there are exactly $(n-1)$ elements smaller than or equal to the $n$th smallest element.
- Therefore, the $n$th smallest element is equivalent to the **median** in $\text{sorted}(A \cup B)$.
- Because the inputs are sorted arrays and the problem asks for a logarithmic time limit, binary search (or a similar approach) is a promising method.

Idea:
- Finding the $n$-th smallest element of the two arrays only requires us to merge *up to* the $n$th element of the merged array. 
- Since both lists are sorted, we should discard parts of A and B if they are larger than the $n$th smallest element we are looking for.

> [!idea]
> Consider the merged array of length $2n$. We only want its first $n$ numbers (“left half”). Those $n$ numbers come from taking some $i$ from $A$ and the rest $j = n − i$ from $B$. The task is just to find the right $i$, i.e., how many elements from $A$ are in the $n$ smallest elements of $A \cup B$?
> 
> If we know $i$ elements are from $A$, then we know $j = n − i$ must come from $B$. 
> Therefore, we can binary search for $i$ in $A$. 


## Brute Force 

### Merge Sort: O(n) 

If we put the elements of two arrays in one array $A \cup B$ and arrange them in order, then clearly this is a [[modules/4 Divide and Conquer/Merge Sort|merge sort]] algorithm to find the $n$th smallest element in the merged array.

However merge sort is not needed:
- Merge sort is $O(n log n)$ but problem has $O(log n)$ time limit.
- Both arrays are already sorted, so we don't even need to actually recursively merge and sort the arrays ⇒ we just do the sorting procedure from merge sort, which compares elements from A and B in a single pass with $O(n + m)$ time.

Procedure:
- Set two pointers `p1` and `p2` at the start of each array and get the smallest element from A and B by comparing `A[p1]` and `B[p2]`. Put the smallest of the two in a new array. Repeat until we have found the $n$th smallest element in the new array.

## Optimal Solution

### Binary Search: O(log n)

Binary search (partition) the two arrays such that:
1. Number of elements on each half is the same
2. Every element on the left side is less than (or equal to) every element on the right side

Finding the median (the $n$-th smallest element) of the two arrays only requires us to find up to the $n$th smallest element of the merged array with size $2n$. 

The $n$th smallest element is found in the first $n$ elements of $A\cup B$. 

The key idea is to partition both arrays such that the left half contains exactly $n$ smaller elements (and the right half contains the other larger elements). This way, the median lies in the smaller half which consists of  `A_left` and `B_left`. 

![[median-in-two-sorted-arrays.png]]
![[median-of-two-sorted-arrays-general.png]]

> If the partitions satisfy $A[i] \le B[j+1]$ and $B[j] \le A[i+1]$ with $i + j = n$,
> then the $n$-th smallest element of $\operatorname{sorted}(A \cup B)$ is $\max(A[i], B[j])$.


**Setup:**
1. Define the search space $[0..n]$ as `left = 0` and `right = n`.
2. Compute the partition index of A as `i = (left + right)/2 = n/2` (midpoint).
   Consequently, the partition index of `B` is `j = n - i`.
3. Define the boundary elements as:
	- `maxLeftA = A[i]`. If `i <= 0`, set it as `maxLeftA = float(-inf)`.
		- if the left partition of A is empty (`A[1..i]`), we set `A[i] = -inf` so that when we check `A[i] ≤ B[j+1]`, this will hold — which is exactly what we want, since we ran out of elements and we don't want to accidentally add anything too big.
	- `minRightA = A[i+1]`.  If `i > n`, set it as `minRightA = float(inf)`.
		- if the right partition of A is empty (`A[i+1..n]`), we set the largest value there to +ve infinity.
	- `maxLeftB = B[j]`. If `j <= 0`, set it as `maxLeftB = float(-inf)`.
	- `minRightB = B[j]`. If `j > n`, set it as `minRightB = float(inf)`

We need to consider the edge cases when the left or right partitions run out of elements, by making sure the comparisons still hold. 

**Recursive Case:**
- If `maxLeftA ≤ minRightB` **and** `maxLeftB ≤ minRightA`:
	- found median!
- else if `maxLeftA > minRightB`:
	- move towards left in `A` ⇒ set `right = i - 1`
	- `maxLeftA` is too large to be in the smaller half and we should look for a smaller partition value of A
- else `maxLeftB > minRightA`:
	- move towards right in `A` ⇒ `left = i + 1`
	- `minRightA` is too small to be in the larger half and we should look for a larger partition value of `A`.

> [!NOTE]-
> We choose a cut (partition) in the first array, and accordingly calculate the cut in the second array such that the total number of elements on the left side equals the number of elements on the right (or differs by one if the total number is odd). For the correct partition, the maximum of the left parts should be less than or equal to the minimum of the right parts.  
> 
> - **Same sizes:** Suppose both arrays have size 100. If we split at index 30 in one array A, then we must split at index 70 in the other array B. 
> - **Different sizes:** Or suppose one array has size 100 and the other has size 200. If we split at index 40 in the first array, then we must split at 110 in the other so that $40 + 110 = 150$ which is the middle of the combined lengths $100 + 200$. (There may be some one-off errors here, but the basic idea is correct.)
> 
> To check this, we compare the maximum of the left side from both arrays with the minimum of the right side. If the condition is not met, we move the binary search window either left or right depending on which condition fails. This process continues until we find the right partition.  
>   
> Once the correct partition is found, the median is calculated based on the total number of elements. If the total is even, we take the average of the two middle values (i.e., max of left part and min of right part). If the total is odd, the median is the max of the left part since it would be the middle element.

## *References*

- [Binary Search : Median of two sorted arrays of different sizes.](https://www.youtube.com/watch?app=desktop&v=LPFhl65R7ww)
	- Great video!!
- [Median of Two Sorted Arrays - LeetCode](https://leetcode.com/problems/median-of-two-sorted-arrays/description/)
- [4. Median of Two Sorted Arrays - In-Depth Explanation](https://algo.monster/liteproblems/4)
