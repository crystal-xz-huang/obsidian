
In the lectures, we looked at the [[Matrix Chain Multiplication]] problem:

- **Instance:** a sequence of matrices $M_1, M_2, \ldots, M_n$, where matrix $M_i$ has dimensions $s_{i-1} \times s_i$ (to enforce compatibility for matrix multiplication).

- **Problem:** place brackets to minimise the total number of multiplications required to find the product $M_1 \times M_2 \times \cdots \times M_n$.


and the [[Maximising an Expression]] problem:

- **Instance:** a sequence of numbers with operations $+$, $-$ or $\times$ between them, e.g. $1 + 2 - 3 \times 6 - 1 + 2$.

- **Problem:** place brackets to maximise the value of the expression.


Aside from the superficial similarity (both problems are about placing brackets), the solutions to these problems also have a similar structure. In both problems, we needed to ==solve every contiguous subarray by recursing into the smaller subarrays left and right of each possible splitting point==.

Consider whether the following problems are solvable using the same structure.

---

### Cutting Logs

Suppose you need to cut logs, and you need to hire a lumberjack. The most affordable one charges money according to the length of the stick being cut. Their cutting saw allows them to make only one cut at a time.  

Note that different cutting orders can lead to different prices. For example, consider a stick of length $10$ m that has to be cut at $2$, $4$, and $7$ m from one end. There are several choices. One can cut first at $2$, then at $4$, then at $7$. This leads to a price of $10 + 8 + 6 = 24$ because the first stick was of $10$ m, the resulting stick of $8$ m, and the last one of $6$ m. Another choice could cut at $4$, then at $2$, then at $7$. This would lead to a price of $10 + 4 + 6 = 20$, which is cheaper.  

Suppose now that you have a log of length $m$, and a sequence of cuts $C[1..n]$. The problem is to determine the minimum amount to pay the lumberjack to make these cuts.  

> [!answer] Answer: True
> Suppose our subproblem $\operatorname{opt}(i, j)$ is the optimal cost to cut the log from cutting point $i$ to cutting point $j$. Cutting at these points means that we have a *sub-log* of length $C[j] - C[i]$. Then, we necessarily have to cut every cutting point in between $i$ and $j$, so we need to select the best *first* cut that partitions the sub-log — i.e. the optimal splitting point.
> 
> We explicitly give the recurrence:
> 
> $$
> \operatorname{opt}(i, j) = C[j] - C[i] + \min_{i < k < j} \big[\, \operatorname{opt}(i, k) + \operatorname{opt}(k, j) \,\big].
> $$
> 
> Our base cases are no cost to cut any adjacent cuts, while we compute in order of increasing $j - i$.

---

### Restaurants

There are $n$ restaurants lined in a row with the $i$-th restaurant having size $S[i]$. Our goal is to eventually merge all $n$ restaurants together such that the final restaurant forms a single restaurant. However, you can only merge restaurants in the following manner:

- You can only merge two adjacent restaurants at a time, so that the new restaurant is the physical union of two buildings.
- The size of the new restaurant is the sum of the two restaurants being merged.
- The cost of a merge is equal to the size of the larger restaurant.
- The total cost of a sequence of merges is the sum of the costs of the individual merges.

The problem is to compute the minimum total cost of creating one large restaurant from the original $n$ restaurants.

> [!answer] Answer: True
> The solution here is to find the optimal splitting point — i.e. the optimal merge. For each $\operatorname{opt}(i, j)$ denoting the optimal cost for merging restaurants indexed between $i, j$ inclusive, this will be equal to the cost of merging the best contiguous pairwise partition.  
> 
> That is, the recurrence is
> 
> $$
> \operatorname{opt}(i, j)
> = \min_{i \le k \le j} 
> \Big[
> \operatorname{opt}(i, k)
> + \operatorname{opt}(k + 1, j)
> + \max_{i \le k \le j}\big(A[k] - A[i - 1],\, A[j] - A[k]\big)
> \Big],
> $$
> 
> where $A[k] = \sum_{t = 1}^{k} S[t]$.  
> 
> This is similar to matrix multiplication, where the goal was to minimise the cost, and the solution was to find the optimal splitting point of two partitions. As an exercise, compare the base cases, order of computation, and final solution to that of matrix multiplication.

---

### Number of Palindromic Subsequences

Let $S[1..n]$ be a string of $n$ characters. A *palindromic subsequence* is a subsequence of $S$ that also forms a palindrome. Recall that a palindrome is a string that is read the same forwards and backwards, such as *KAYAK* and *RACECAR*.

The problem is to find the number of palindromic subsequences.  

> [!error] Answer: False
> We cannot use the optimal splitting point idea to find palindromes. Suppose we want to compute $\operatorname{opt}(i, j)$ to find and count a palindrome; we cannot use some splitting point $k$ such that $\operatorname{opt}(i, k)$, $\operatorname{opt}(k, j)$ forms a palindrome, since the subproblems must themselves form palindromes — i.e. we would only find *double palindromes*! Moreover, it’s quite difficult to define a subproblem definition using this heuristic at all, since palindromes *build outwards*.

---

### Maximum Pairwise Mean

Suppose you have an array of $n$ numbers, and you want to compute the maximum pairwise adjacent mean of the whole array by placing parentheses. We compute in order of parentheses, and each time we take a pairwise mean, we replace both numbers in-place with the mean.  

For example, the maximum pairwise adjacent mean of the array $[2, 4]$ is $3$, since there is only one way to take the mean of two numbers.  

It becomes more complicated when we have a non-trivial array; consider $[2, 3, 4]$, where we could take the pairwise mean of $2, 3$ first before subsequently taking the mean of that with $4$, to produce the result $(2.5 + 4)/2 = 3.25$. Alternatively, we could take the pairwise mean of $3, 4$ first then take the mean of that with $2$ to produce the result $(2 + 3.5)/2 = 2.75$, which is suboptimal.  

For another example, if we had the array $[7, 4, 9, 3]$, the best solution is to take the mean of $9$ and $3$ first, then take the mean of $4$ and $6$ (just produced), and subsequently $7$ and $5$, for the maximum value of $6$.

The problem is to compute the maximum pairwise adjacent mean. We can solve this using dynamic programming; does the dynamic programming solution admit the same structure?  

> [!answer] Answer: True
> The recurrence for the dynamic programming solution is to again look for the optimal splitting point. Suppose $\operatorname{opt}(i, j)$ is the optimal solution for the subarray between indices $i, j$ inclusive. Then, the recurrence should be the maximum pairwise mean of two subarrays that partition $A[i..j]$.
> 
> As an aside, this problem can be solved with greedy. As an exercise, can you give a heuristic and subsequent proof that this works?
