![[COMP3121_9101-2.6.pdf]]


# Solution

> [!example|style-ad] Part A
> In this problem, both the drinks and the vouchers are given in no particular order. To apply a greedy algorithm, we should choose a sensible order to process them in. 
>     
> We can order the drinks in ascending order, then assign one voucher to each drink in this ordering. With the drinks in this order, any allocation of vouchers is simply a [[Permutations and Inversions#Permutations|permutation]] of the voucher amounts $\{v_1,v_2,\ldots,v_n\}$. The first voucher in the permutation is used on the weakest drink, and so on.
> 
> *The optimal permutation is in ascending order of value; we should use the lowest value voucher on the weakest drink, and so on.*
>     
> Now, we will use an exchange argument to show that an algorithm that assigns vouchers in this way is optimal. Suppose that $G$ is your ordering of vouchers, and that $A$ is some other alternative ordering i.e. $G \neq A$. We know that at least one inversion in $A$ must be an *adjacent inversion*, where the two vouchers that are 'out of order' are consecutive with respect to our ordering of vouchers. That is, there is some index where $A_i > A_{i+1}$. 
> 
> Prove that if we resolve this inversion (by exchanging $A_i$ and $A_{i+1}$), then the amount of caffeine will be no worse (i.e. the same or better).
> 
> **Hint**: Define your cost function and show that your exchange is valid and optimal
> 

## Part A

> [!NOTE]-
> 1. **Fix the drink order.** Sort drinks so $c_1 \le \cdots \le c_n$.
> 
> 2. **Represent any voucher assignment.**  Any ordering $A = (A_1, \dots, A_n)$ of the voucher values $\{v_1, \dots, v_n\}$ assigns $A_i$ servings to drink $i$.
> 
> 3. **Objective (total caffeine):**  
> $$
> \text{Caff}(A) = \sum_{i=1}^{n} A_i\,c_i
> $$
> 
> 4. **Exchange step for an adjacent inversion.** Suppose $A_i > A_{i+1}$ (out of order).
> 	1. **Before swap:** $A_i c_i + A_{i+1} c_{i+1}$  
> 	2. **After swap:** $A_{i+1} c_i + A_i c_{i+1}$  
> 	3. **Change:**  
>      $$
>      \Delta = (\text{after}) - (\text{before})
>             = (A_i - A_{i+1})(c_{i+1} - c_i) \ge 0,
>      $$
> 
>      since $A_i > A_{i+1}$ and $c_{i+1} \ge c_i$.
> 
> Thus resolving an adjacent inversion **does not decrease** total caffeine (and increases it if $c_{i+1} > c_i$). Repeating removes all inversions, yielding vouchers in **non-decreasing** order aligned with $c$ — the greedy order — so it’s optimal.

The optimal ordering is to sort the vouchers in ascending order. We now show that this is optimal with an exchange argument via inversions.

%% We will prove this is optimal by showing that any _inversion_ (out-of-order adjacent pair of vouchers) can be swapped without decreasing total caffeine. %%

1. Form a suitable definition for an inversion with respect to your problem 

Fix the drinks in ascending order of caffeine content $c_1 \le c_2 \le \cdots \le c_n$.

Denote permutations of $\{1,\dots,n\}$ as allocations, where the allocation $\pi$ represents using voucher $\pi(i)$ on drink $i$. We define an inversion as follows:

> a pair $(i,j)$ of indices forms an inversion in $\pi$ if and only if $i<j$ and $v_{\pi(i)} > v_{\pi(j)}$.

That is, an inversion occurs when we use a higher value voucher (more servings) on a weaker drink earlier, and a lower value voucher on a stronger drink later.

2. Show that the greedy solution has zero inversions. This is usually by design.

The greedy allocation $G$ has no inversions and so it suffices to prove that resolving an adjacent inversion is always an improvement (or breaks even).

%% Explanation: By construction, the greedy solution sorts drinks in ascending order, and assigns vouchers to drinks in ascending order. So for all $i < j$, we have $v_{G(i)} \leq v_{G(j)}$. Therefore the greedy allocation has no inversions. %%

3. Consider any solution π that has at least one inversion. 

Let $A$ be any alternative allocation with at least one inversion. It follows that $A$ has an adjacent inversion, i.e. there is some index $i$ such that $v_{A(i)} > v_{A(i+1)}$.

Define the new ordering $A^*$ as follows:
$$
A^\ast(k) =
\begin{cases}
A(i+1) & \text{if } k = i, \\
A(i)   & \text{if } k = i+1, \\
A(k)   & \text{otherwise}.
\end{cases}
$$

We now prove that resolving the inversion in this way is an improvement or breaks even, i.e. that the total caffeine in allocation $A^*$ is **no less than** in allocation $A$. By a sequence of such swaps, we can always reach the greedy allocation $G$, and therefore, no other allocation $A$ can acheive a strictly greater total caffeine than the greedy solution.

Let $S_{\pi}$ denote the total caffeine for any allocation $\pi$ of $\{1,\dots,n\}$:

$$
S_{\pi} = \sum_{i=1}^n v_{\pi(i)} \cdot c_i.
$$

In $S_A$ and $S_{A^*}$, terms $1$ to $i−1$ inclusive and terms $i+2$ to $n$ inclusive match exactly.
Letting $D$ be the sum of these terms, we have that


$$
S_A = D + \big( v_{A(i)} c_i + v_{A(i+1)} c_{i+1} \big)
$$
and

$$
S_{A^\ast} = D + \big( v_{A(i+1)} c_i + v_{A(i)} c_{i+1} \big).
$$

> [!NOTE]
> The total caffeine **before** the swap contributes
> $$
> v_{A(i)} c_i + v_{A(i+1)} c_{i+1}
> $$
> and **after** the swap contributes
> $$
> v_{A(i+1)} c_i + v_{A(i)} c_{i+1}.
> $$

Thus, the change is

$$\begin{aligned}  
S_{A^\ast} - S_A 
&= \big(v_{A(i+1)}c_i + v_{A(i)}c_{i+1}\big) - \big(v_{A(i)}c_i + v_{A(i+1)}c_{i+1}\big) \\ 
&= (v_{A(i)} - v_{A(i+1)})(c_{i+1} - c_i).  
\end{aligned}$$

Since $v_{A(i)} > v_{A(i+1)}$ and $c_{i+1} \ge c_i$, it follows that  

$$S_{A^\ast} - S_A \ge 0.$$

Therefore, $A^*$ is no worse than $A$, and we could continue resolving adjacent inversions, each time increasing the total caffeine or keeping it the same. It follows that, $S_A \leq S_G$, i.e. any alternative allocation is no better than the greedy allocation, and therefore the greedy solution is optimal. 

%% After resolving any adjacent inversion, the total caffeine will be no worse (i.e. the same or better). %%

---

##### Example 1
###### Setup

Let $(c_1,\dots,c_n)$ be caffeine-per-serving values of the drinks and $(v_1,\dots,v_n)$ be serving counts of the vouchers. 

Fix the drinks in **nondecreasing (ascending)** order 
$$
c_1 \le c_2 \le \cdots \le c_n.
$$
For any permutation $\pi$ of $\{1,\dots,n\}$, the total caffeine is
$$
\mathrm{Caff}(\pi) = \sum_{i=1}^n v_{\pi(i)}\,c_i.
$$
Then $\mathrm{Caff}(\pi)$ is maximized when the vouchers are also in **nondecreasing (ascending)** order with the drinks, i.e.
$$
v_{\pi(i)} \le v_{\pi(i+1)} \quad \text{for all } i.
$$

###### Proof (exchange argument via adjacent inversions)

Suppose, for contradiction, that an optimal permutation $\pi^*$ contains an **adjacent inversion** at some position $i$:
$$
v_{\pi^*(i)} > v_{\pi^*(i+1)} \quad\text{while}\quad c_i \le c_{i+1}.
$$
Let $a=\pi^*(i)$ and $b=\pi^*(i+1)$. Consider swapping these two vouchers to form a new permutation $\pi'$ with
$$
\pi'(i)=b,\quad \pi'(i+1)=a,\quad \text{and}\quad \pi'(k)=\pi^*(k)\ \text{for}\ k\notin\{i,i+1\}.
$$
Only the two affected terms change in the sum. The total caffeine **before** the swap contributes
$$
v_a c_i + v_b c_{i+1},
$$
and **after** the swap contributes
$$
v_b c_i + v_a c_{i+1}.
$$
Thus, the change is
$$
\Delta = (\text{after}) - (\text{before})
       = (v_a - v_b)(c_{i+1} - c_i).
$$
Because $v_a>v_b$ and $c_{i+1}\ge c_i$, we have $\Delta \ge 0$, with strict $>0$ whenever $c_{i+1}>c_i$. Hence the swap **does not decrease** the total caffeine and in fact **increases** it if the two drinks differ.

Therefore, any adjacent inversion can be removed without harming optimality, and repeatedly removing inversions yields a permutation with **no** adjacent inversions, i.e. a nondecreasing sequence $v_{\pi(i)}$. This permutation maximizes $\mathrm{Caff}(\pi)$. 


---

# Notes

Input: 
- $C[1 \cdots n]$ the array of $n$ drinks, where each drink $i$ has an associated caffeine $c_1, c_2, \ldots, c_n$
- $V[1 \cdots n]$ the array of $n$ vouchers 
- Each drink $i$ has $\bbox[5px, border: 2px solid lightblue]{c_i}$ mg of caffeine per serving
- Each voucher $j$ has $\bbox[5px, border: 2px solid lightpink]{v_j}$ number of servings for a unique drink $i$ 

Task: Assign each voucher $v_j$ to a unique drink $c_i$ to maximize total caffeine.

> [!remark]
> - [[The Stable Matching Problem and Gale-Shapley Algorithm#Perfect Matching|Perfect Matching]] 
> 	- Form a **one-to-one pairing** between vouchers $\{ v_1, v_2, \ldots, v_n \}$ and drinks $\{ c_1, c_2, \ldots, c_n \}$ so that every voucher gets assigned to exactly one drink (and vice versa).
> 	- If there are $n$ drinks and $n$ vouchers, there are $n!$ possible permutations (pairs of v and c)
> - Goal
> 	- **Maximise** the total caffeine across all pairs $(c_i, v_j)$
> 	- Find the permutation $\pi$ that maximises the total caffeine 

Define:
- $c_i$ : the caffeine per serving for drink $i$  ($1 \leq i \leq n$)
- $v_j$ : the number of servings for voucher $j$  ($1 \leq j \leq n$)
- Let $\pi(i)$ denote the index of the voucher at position $i$ of the permutation $\pi$.
> $\pi(i)$ = index of the voucher that is paired/assigned to drink $i$ in the permutation 
>          = the voucher paired to drink $i$
- Each drink $i$ gets voucher $\pi(i)$ of value $v_{\pi(i)}$ (which is the number of servings).
- The pair (drink $i$, voucher $\pi(i)$) contributes $v_{\pi(i)} \times c_i$ milligrams of caffeine to the total.
- The total caffeine consumed is the sum over all drinks:

$$
\text{TotalCaffeine}(\pi) = \sum_{i=1}^n v_{\pi(i)} \cdot c_i
$$

Intuition: 
- Maximise the product $v_j \times c_i$ = amount of caffeine for every match
- Expect **large vouchers (many servings)** to go with **strong drinks (high caffeine)**.
- A voucher with many servings should be used on a strong (high-caffeine) drink.
- A small voucher (few servings) should be used on a weak (low-caffeine) drink.

> [!def] Rearrangement Inequality
> To maximize $\sum_i a_i b_i$, sort both sequences ($a_i$) and ($b_i$) in the same direction (ascending–ascending or descending–descending).

**Input:**  
Two arrays of equal length $n$:
- `caffeine[]` → $c_1, c_2, \dots, c_n$
- `vouchers[]` → $v_1, v_2, \dots, v_n$
    
**Output:**  
Maximum possible total caffeine

**Algorithm:**
- Sort $c_i$​ in ascending order: $c_1 \leq c_2 \leq \cdots \leq c_n$
- Sort $v_j$​ in ascending order: $v_1 \leq v_2 \leq \cdots \leq v_n$
- Pair them by index, in this order.
	- Repeatedly assign the smallest voucher to the weakest drink
	- … and so on, up to the largest voucher with the strongest drink.
- Compute the total caffeine across all pairs
$$
\text{TotalCaffeine}(\pi) = \sum_{i=1}^n v_{i} \cdot c_i
$$

```python
def max_total_caffeine(caffeine, vouchers):
    caffeine.sort()    # ascending
    vouchers.sort()    # ascending
    total = 0
    for i in range(len(caffeine)):
        total += caffeine[i] * vouchers[i]
    return total
```


---


## Permutation

> [!def] Permutation
> A _permutation_ is an _ordering_ (or rearrangement) of a set of items.

Say we have 3 vouchers $v_1, v_2, v_3$.
A permutation of these vouchers is any reordering of the indices:
$$[1,2,3] \;,\; [1,3,2]\;,\; [2,1,3]\;,\; [2,3,1]\;,\; [3,1,2]\;,\; [3,2,1].$$

Each permutation represents a different way to assign vouchers to drinks.

## Permutation Function π

A **permutation** $\pi$ represents _one distinct ordering_ of items (out of all possible rearrangements).
A **permutation function** $\pi(i)$ maps gives the item at position $i$ within that ordering.
