---
aliases:
  - Median of Two Sorted Arrays
tags:
  - topic/binary-search
  - topic/divide-and-conquer
cssclasses:
  - img-grid
---

# 7.6 nth Smallest

![[COMP3121_9101-7.6.pdf#height=400]]

> [!problem]
> Let $A[1..n]$ and $B[1..n]$ be two sorted arrays each containing $n$ distinct integers, and $A$ and $B$ have no elements in common. You may assume that $n$ is a power of two, say $2^\ell$. Describe a $O(\log n)$ algorithm that finds the $n$th smallest element of $A ∪ B$ (where $A ∪ B$ is the array obtained by merging $A$ and $B$ together).

# Notes 

> [!observation]
> The $n$th smallest element in the combined array of size $2n$ is the **median** of the two arrays. Median = $(n + n) / 2 = 2n / 2 = n$.

Observations:
- Consider the two sorted arrays $A$ and $B$, both of size $n$.
- The union of $A$ and $B$ is an array of size $2n$. 
- In the sorted $A\cup B$, there are exactly $(n-1)$ elements smaller than or equal to the $n$th smallest element.
- Therefore, the $n$th smallest element is equivalent to the **median** in $\text{sorted}(A \cup B)$.
- Because the inputs are sorted arrays and the problem asks for a logarithmic time limit, binary search (or a similar approach) is a promising method.

Idea:
- Finding the median (the n-th smallest element) of the two arrays only requires us to merge up to the $k$th element of the merged array, where $k=n$.
- Since both lists are sorted, we should discard parts of A and B if they are larger than the $k$th smallest element we are looking for.

### Brute Force 

#### Merge Sort: O(n) 

If we put the elements of two arrays in one array $A \cup B$ and arrange them in order, then clearly this is a [[modules/04 Divide and Conquer/Merge Sort|merge sort]] algorithm to find the $n$th smallest element in the merged array.

However merge sort is not needed:
- Merge sort is $O(n log n)$ but problem has $O(log n)$ time limit.
- Both arrays are already sorted, so we don't even need to actually recursively merge and sort the arrays ⇒ we just do the sorting procedure from merge sort, which compares elements from A and B in a single pass with $O(n + m)$ time.

Procedure:
- Set two pointers `p1` and `p2` at the start of each array and get the smallest element from A and B by comparing `A[p1]` and `B[p2]`. Put the smallest of the two in a new array. Repeat until we have found the $n$th smallest element in the new array.

### Optimal Solution

Intuition:

Binary search (partition) the two arrays such that:
1. Number of elements on each half is the same
2. Every element on the left side is less than (or equal to) every element on the right side

Finding the median (the $n$-th smallest element) of the two arrays only requires us to find up to the $n$th smallest element of the merged array with size $2n$. 

The $n$th smallest element is found in the first $n$ elements of $A\cup B$. 

The key idea is to partition both arrays such that the left half contains exactly $n$ smaller elements (and the right half contains the other larger elements). This way, the median lies in the smaller half which consists of  `A_left` and `B_left`. 

![[median-in-two-sorted-arrays.png]]
![[median-of-two-sorted-arrays-general.png]]

> If the partitions satisfy $A[i] \le B[j+1]$ and $B[j] \le A[i+1]$ with $i + j = n$,
> then the $n$-th smallest element of $\operatorname{sorted}(A \cup B)$ is $\max(A[i], B[j])$.


**Setup:**
1. Define the search space $[0..n]$ as `left = 0` and `right = n`.
2. Compute the partition index of A as `i = (left + right)/2 = n/2` (midpoint).
   Consequently, the partition index of `B` is `j = n - i`.
3. Define the boundary elements as:
	- `maxLeftA = A[i]`. If `i <= 0`, set it as `maxLeftA = float(-inf)`.
		- if the left partition of A is empty (`A[1..i]`), we set `A[i] = -inf` so that when we check `A[i] ≤ B[j+1]`, this will hold — which is exactly what we want, since we ran out of elements and we don't want to accidentally add anything too big.
	- `minRightA = A[i+1]`.  If `i > n`, set it as `minRightA = float(inf)`.
		- if the right partition of A is empty (`A[i+1..n]`), we set the largest value there to +ve infinity.
	- `maxLeftB = B[j]`. If `j <= 0`, set it as `maxLeftB = float(-inf)`.
	- `minRightB = B[j]`. If `j > n`, set it as `minRightB = float(inf)`

We need to consider the edge cases when the left or right partitions run out of elements, by making sure the comparisons still hold. 

**Recursive Case:**
- If `maxLeftA ≤ minRightB` **and** `maxLeftB ≤ minRightA`:
	- found median!
- else if `maxLeftA > minRightB`:
	- move towards left in `A` ⇒ set `right = i - 1`
	- `maxLeftA` is too large to be in the smaller half and we should look for a smaller partition value of A
- else `maxLeftB > minRightA`:
	- move towards right in `A` ⇒ `left = i + 1`
	- `minRightA` is too small to be in the larger half and we should look for a larger partition value of `A`.

---


Since $A$ and $B$ are sorted arrays, we have that

$$
A[1] \le A[2] \le \cdots \le A[n] \quad \text{and} \quad B[1] \le B[2] \le \cdots \le B[n].
$$


Consider the partitions

$$
A_{\text{left}} = A[1..i], \quad A_{\text{right}} = A[i+1..n],
$$

$$
B_{\text{left}} = B[1..j], \quad B_{\text{right}} = B[j+1..n],
$$

so that the left halves together contain exactly $n$ elements since $i + j = n$.

**Claim.** Every element in $A_{\text{left}} \cup B_{\text{left}}$ is smaller than every element in $A_{\text{right}} \cup B_{\text{right}}$.

Because the arrays are sorted, the largest element in $A_{\text{left}}$ is $A[i]$, and the largest element in $B_{\text{left}}$ is $B[j]$. Similarly, the smallest element in $A_{\text{right}}$ is $A[i+1]$, and the smallest element in $B_{\text{right}}$ is $B[j+1]$.

The given inequalities

$$
A[i] \le B[j+1] \quad \text{and} \quad B[j] \le A[i+1]
$$

imply that both of these left-side maxima are less than or equal to both right-side minima.  
Therefore, for every $x \in A_{\text{left}} \cup B_{\text{left}}$ and every $y \in A_{\text{right}} \cup B_{\text{right}}$, we have $x \le y$.  
Hence, all $n$ elements on the left are the globally smallest $n$ elements of $A \cup B$. ∎

Since the left half $A_{\text{left}} \cup B_{\text{left}}$ contains exactly the smallest $n$ elements, the maximum of these $n$ elements is the $n$th smallest element at index $n$ in $\operatorname{sorted}(A \cup B)$.  

The largest element in the left half is

$$
\max(\max(A_{\text{left}}), \max(B_{\text{left}})) = \max(A[i], B[j]).
$$

Therefore, the $n$-th smallest element of $\operatorname{sorted}(A \cup B)$ is $\boxed{\max(A[i], B[j])}$.

Since the arrays are sorted, we can find such indices $i$ and $j = n - i$ using binary search in $O(\log n)$ time by checking which inequality is violated and adjusting $i$ accordingly.

---

> [!NOTE]-
> We choose a cut (partition) in the first array, and accordingly calculate the cut in the second array such that the total number of elements on the left side equals the number of elements on the right (or differs by one if the total number is odd). For the correct partition, the maximum of the left parts should be less than or equal to the minimum of the right parts.  
> 
> - **Same sizes:** Suppose both arrays have size 100. If we split at index 30 in one array A, then we must split at index 70 in the other array B. 
> - **Different sizes:** Or suppose one array has size 100 and the other has size 200. If we split at index 40 in the first array, then we must split at 110 in the other so that $40 + 110 = 150$ which is the middle of the combined lengths $100 + 200$. (There may be some one-off errors here, but the basic idea is correct.)
> 
> To check this, we compare the maximum of the left side from both arrays with the minimum of the right side. If the condition is not met, we move the binary search window either left or right depending on which condition fails. This process continues until we find the right partition.  
>   
> Once the correct partition is found, the median is calculated based on the total number of elements. If the total is even, we take the average of the two middle values (i.e., max of left part and min of right part). If the total is odd, the median is the max of the left part since it would be the middle element.


<hr class="dots"/>

## LeetCode

### Approach I: Binary Search, Recursive 

#### Intuition

Recall that both arrays are sorted, so we know that:
- $A_{\text{left}} < A_{\text{right}}$
- $B_{\text{left}} < B_{\text{right}}$

Without loss of generality assume $A_{mid} \leq B_{mid}$ in this example.
We have the following result:
- $A_{\text{left}} < A_{\text{mid}}  < B_{\text{mid}} < B_{\text{right}}$

Thus,

- $A_{\text{left}}  < B_{\text{right}}$

Note that since both all elements distinct; $A\cap B = \varnothing$, $\leq$ and $<$ are equivalent. 

![[Median of Two Sorted Arrays.png|400]]

Since A is sorted, we know that $A_{\text{left}} < B_{\text{right}}$. Then if $A_{mid} \leq B_{mid}$ then we know that $A_{\text{left}}$ is smaller than the two halves $A_{\text{right}}$ and $B_{\text{right}}$. Although we don't know where exactly these elements are, what we do know is $A_{\text{left}}$ **does not intersect** with $A_{\text{right}} \cup B_{\text{right}}$! The same logic applies to the combined segment $A_{\text{left}} \cup B_{\text{left}}$ and $B_{\text{right}}$, which also do not intersect.

Hence, we have divided the merged array $A \cup B$ such that each segment is monotonic and disjoint. 


**The following step is the most important one.**
We are looking for the median of $\text{sorted}(A \cup B)$ which is at index $n$ in the combined array.
Let's denote it as $k$ to not get confused with the array lengths.


- Compare the middle values $A_{\text{mid}}$ and $B_{\text{mid}}$
- Let the index of the median value in the $\text{sorted}(A \cup B)$ be $k$.
- ==If we remove one half of an array, index $k$ may change!== Suppose we removed $3$ elements that are smaller than the original $k$th smallest element, we shall look for the $(k−3)$th smallest element from the **remaining** arrays.

![img](https://leetcode.com/problems/median-of-two-sorted-arrays/Figures/4/exp_1.png)

More specifically:

- If $k$ is larger than half the total number of elements in $\text{sorted}(A \cup B)$, it means that the $k^{\text{th}}$ element is in the **second (larger) half** of $\text{sorted}(A \cup  B)$. Thus, $A_{\text{left}}$ (or $B_{\text{left}}$, the smaller of the two smaller sections according to the comparison) is guaranteed **not** to contain this element, and we can safely cut this half and reduce $k$ by the length of the removed half.
- If $k$ is **not** larger than half the total number of elements in $\text{sorted}(A \cup  B)$, it means that the $k^{\text{th}}$ element is in the **first (smaller) half** of $\text{sorted}(A \cup  B)$. Thus, $B_{\text{right}}$ (or $A_{\text{right}}$, the larger of the two larger sections according to the comparison) is guaranteed **not** to contain this element, and we can safely discard it. 
	- Note that we don't need to modify $k$ this time, since we removed one larger half that doesn't affect the order of the $k^{\text{th}}$ smallest element.
- We can continue our search like above in the remaining arrays. Once we cut off part of either $A$ or $B$, we regard the remaining arrays as modified $A$ and $B$ and restart this algorithm. 

|![img](https://leetcode.com/problems/median-of-two-sorted-arrays/Figures/4/9.png)|
| :-: |
|Note that the following picture represents one case only: we consider the case that $a_{\text{value}} < b_{\text{value}}$, thus we remove either the smaller half of $A$ or the larger half of $B$. If the comparison result is $a_{\text{value}} \ge b_{\text{value}}$, we shall remove either the smaller half of $B$ or the larger half of $A$.|

- We cut one of the two arrays in half at each step, so this approach has a logarithmic time complexity.
- We won't create copies of two arrays repeatedly, because that would introduce a linear time complexity at least. Instead, we just treat a part of the original array as the modified array for the next step, so that we can repeat the process on the original array without making any duplication. To do this, we need to maintain four pointers, two pointers for each array. For example, `a_start` and `a_end` represent an inclusive range $[a_{\text{start}}, a_{\text{end}}]$ of $A$.
	- For array $A$: maintain $a_{\text{start}}$ and $a_{\text{end}}$ to denote the current subarray $A[a_{\text{start}} \ldots a_{\text{end}}]$.
	- For array $B$: maintain $b_{\text{start}}$ and $b_{\text{end}}$ to denote the current subarray $B[b_{\text{start}} \ldots b_{\text{end}}]$.

#### Algorithm

```python
class Solution:
    def findMedianSortedArrays(self, A: List[int], B: List[int]) -> float:
        na, nb = len(A), len(B)
        n = na + nb

        def solve(k, a_start, a_end, b_start, b_end):
            # If the segment of on array is empty, it means we have passed all
            # its element, just return the corresponding element in the other array.
            if a_start > a_end:
                return B[k - a_start]
            if b_start > b_end:
                return A[k - b_start]

            # Get the middle indexes and middle values of A and B.
            a_index, b_index = (a_start + a_end) // 2, (b_start + b_end) // 2
            a_value, b_value = A[a_index], B[b_index]

            # If k is in the right half of A + B, remove the smaller left half.
            if a_index + b_index < k:
                if a_value > b_value:
                    return solve(k, a_start, a_end, b_index + 1, b_end)
                else:
                    return solve(k, a_index + 1, a_end, b_start, b_end)
            # Otherwise, remove the larger right half.
            else:
                if a_value > b_value:
                    return solve(k, a_start, a_index - 1, b_start, b_end)
                else:
                    return solve(k, a_start, a_end, b_start, b_index - 1)

        if n % 2:
            return solve(n // 2, 0, na - 1, 0, nb - 1)
        else:
            return (
                solve(n // 2 - 1, 0, na - 1, 0, nb - 1)
                + solve(n // 2, 0, na - 1, 0, nb - 1)
            ) / 2
```

#### Complexity Analysis

Let m be the size of array `nums1` and n be the size of array `nums2`.

- At each step, we cut one half off from either `A` or `B`. If one of the arrays is emptied, we can directly get the target from the other array in a constant time. Therefore, the total time spent depends on when one of the arrays is cut into an empty array.
- In the worst-case scenario, we may need to cut both arrays before finding the target element.
- One of the two arrays is cut in half at each step, thus it takes logarithmic time to empty an array. The time to empty two arrays are independent of each other.

![img](https://leetcode.com/problems/median-of-two-sorted-arrays/Figures/4/tc.png)

- Therefore, the time complexity is $O(\log m + \log n)$.

---

### Approach II: Partitioning 

Recall the previous approach where we perform a binary search over the 'merged' array consisting of A and B, resulting in a time complexity of $O(\log (n + n)) = O(\log (2n))$.

We could further improve the algorithm by performing the binary search only on the smaller array of $A$ and $B$, thus the time complexity is reduced to $O(\log (n))$.

The main idea is similar to approach 2, where we need to ==find a point of partition in both arrays such that the maximum of the smaller half is less than or equal to the minimum of the larger half==.

However, instead of partitioning over the merged arrays, we can only focus on partitioning the smaller array, say $A$. Suppose the partition index is $\tt{partitionA}$, we specify that the smaller half contains $2n/2$ elements, and we can use this feature to our advantage by directly making  $\tt{partitionB}$ equal to $(2n)/2 - \tt{partitionA}$, thus the smaller halves of both arrays always contain a total of $2n/2$ elements.

![img](https://leetcode.com/problems/median-of-two-sorted-arrays/Figures/4/2_0.png)

The next step is to compare these edge elements.

![img](https://leetcode.com/problems/median-of-two-sorted-arrays/Figures/4/2_1.png)

If both `maxLeftA <= minRightB` and `maxLeftB <= minRightA` hold, it means that we have partitioned arrays at the correct place.

- The smaller half consists of two sections `A_left` and `B_left`
- THe larger half consists of two sections `A_right` and `B_right`

We just need to find the maximum value from the smaller half as `max(A[maxLeftA], B[maxLeftB])` and the minimum value from the larger half as `min(A[minRightA], B[minRightB])`. The median value depends on these four boundary values and the total length of the input arrays and we can compute it by situation.

![img](https://leetcode.com/problems/median-of-two-sorted-arrays/Figures/4/2_2.png)


If `maxLeftA > minRightB`, it implies that `maxLeftA` is **too large to be in the smaller half** and we should look for a smaller partition value of `A`.

![img](https://leetcode.com/problems/median-of-two-sorted-arrays/Figures/4/2_3.png)

Otherwise, it denotes that `minRightA` is **too small to be in the larger half** and we should look for a larger partition value of `A`.

![img](https://leetcode.com/problems/median-of-two-sorted-arrays/Figures/4/2_4.png)

## Further Readings & References

- [Binary Search : Median of two sorted arrays of different sizes.](https://www.youtube.com/watch?app=desktop&v=LPFhl65R7ww)
	- Great video!!
- [Median of Two Sorted Arrays - LeetCode](https://leetcode.com/problems/median-of-two-sorted-arrays/description/)
- [4. Median of Two Sorted Arrays - In-Depth Explanation](https://algo.monster/liteproblems/4)
