### Overview

**Dynamic Programming**
- Similar to divide-and-conquer. 
	- solves problem by combining solution to sub-problems 
- Different from divide-and-conquer. 
	- sub-problems are not independent 
	- save solutions to repeated sub-problems in table

**Recipe**
- Characterise structure of problem.
	- Identify the optimal substructure property 
- Recursively define value of optimal solution.
- Compute value of optimal solution.
- Construct optimal solution from computed information.

As a general structure, your solution should include the following descriptions:

• A definition of your subproblem.  
• A well-defined recurrence with respect to your subproblem definition and base cases.
• The base case(s) and the final solution(s).  
• The order of computation.  
• An analysis of its correctness and running time.


Your solution should include:
- A clear subproblem definition. 
- Base cases for your subproblem definition.
- A well-defined recurrence with respect to your subproblem definition and base cases.
- Some output that solves the original problem, as a function of the results generated by your recurrence.
- A correct order of computation, with respect to your recurrence.
- Time complexity analysis for your algorithm. 
- Justification that your algorithm solves the problem correctly, with specific reference to the correctness of the base case(s), recurrence and overall answer.


## Dynamic Programming

In dynamic programming, we solve a problem by breaking it into smaller subproblems and then combine the solutions together to solve the original problem. However, dynamic programming improves the running time in the following way: *each subproblem has previously been solved in the past*. In this way, we do not need to recompute solutions; instead, we can simply store them in memory so that they can be accessed quickly. However, this benefit means that not every problem can be solved with dynamic programming. 

### Properties

In particular, there exist a dynamic programming solution if the problem exhibits the following two properties:

- <b>Property 1.</b> **Optimal substructure.**

This means that optimal solutions arise from optimal sub-solutions. In particular, this implies the correctness of any recurrence that correctly solves the subproblems.

- <b>Property 2.</b> **Overlapping subproblems.**  

This means that computing the solution to the current subproblem require subproblems that we have previously solved.

*This means that dynamic programming really does make a difference in the time complexity!*

### Setting up a Dynamic Programming solution

A dynamic programming solution must have the following descriptions.

- <b>Subproblem and Recurrence.</b> The subproblem describes exactly what problem you are solving and the recurrence describes how you combine solutions to previously seen subproblems.
- <b>Base case(s) and Final solution(s).</b> The base cases describe special cases that cannot be solved simply with the recurrence, while the final solution(s) is usually a set of subproblems that return the final solution to the original problem.
- <b>Order of computation.</b> The order of computation describes the sequence of sub- problems that you will resolve. Remember that the order of computation needs to be an ordering so that the current subproblem relies only on subproblems that have previously been solved.

For example (LIS):

> [!solution]
> **Subproblems**
> 
> For each $1 ≤ i ≤ n$, let $len(i)$ be the maximum length of an increasing subsequence of $A[1..i]$ which ends with $A[i]$.
> 
> **Recurrence**
> 
> For $i > 1$,
>
> $$\text{len}(i) = 1 + \max_{\substack{j < i \\ A[j] < A[i]}} \text{len}(j)
> $$
>
> **Base case**
> 
> $\text{len}(1) = 1$
> 
> **Order of computation**
> 
> Solve subproblems in increasing order of $i$. 
> 
> **Overall answer**
> 
> The overall LIS is the best of those ending at some element, i.e., $\displaystyle \max_{1 \leq i \leq n} \text{len}(i).$
> 
> **Time complexity**
>
> $O(n)$ subproblems each taking $O(n)$, and overall answer calculated in $O(n)$ time, for a total running time of $O(n^2)$.

### Analysing the correctness and time complexity

To prove the correctness of dynamic programming algorithms, we need to prove that the recurrence is correct. This corresponds to proving that the problem satisfies the first property: optimal substructure. 

To do so, we use the cut and paste argument as follows:

- Consider an optimal solution $S = {s_1,…,s_k}$ to the current subproblem, and suppose that there exist some index $i$ for which $s_i$ is a suboptimal choice made by any optimal solution.
- Replace $s_i$ with $g_i$, which is the choice made by the dynamic programming recurrence, to form a new solution $S^* = {s_1,…,s_{i−1},g_i,s_{i+1},…,s_k}$.
- Deduce that $S^*$ is optimal, which implies that an optimal solution can be derived from optimal subsolutions.

