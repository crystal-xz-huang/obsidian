# 7.3 \[PS\] Delivering Pizzas

![[COMP3121_9101-7.3.pdf#height=700]]

Design an algorithm that runs in O(n log n) time and determines the number of pizzas you need to bring on each day.


[How to find array elements that fall in a given interval?](https://stackoverflow.com/questions/14913556/how-to-find-array-elements-that-fall-in-a-given-interval?rq=3)

![[delivering-pizzas.excalidraw]]

> [!NOTE]
> Given an integer array B of size n
> Find the elements in B that fall in a given interval (l, r)

First sort the buildings in O(n log n) time

2 binary searches to locate the **boundary indices** of the elements that lie in `[l, r]`.

- Left boundary $i$: smallest index $i$ with $B[i] \geq l$.
	- binary search the first index with $B[i] \geq l$.
- Right boundary $j$: largest index $j$ with $B[j] \leq r$.
	- binary search the last index with $B[i] \geq l$.

If $i > j$ there are no elements in the interval.
Otherwise, the answer is $j - i + 1$.

> [!abstract]
> **Problem:**
> Given two integer arrays `B` and `D`, each of size `n`.
> Each element `D[i]` contains a pair `(l, r)` representing a range interval `[l, r]`.
> Find the number of elements in B that fall within each range interval `D[i]`.
> 
> **Divide and conquer approach:**
> 1. Sort array B - `O(n log n)`
> 2. For each range interval `D[i] = [l, r]`, use binary search to find:
> 	1. `left_index`: the first index in `B` where `B[left_index] >= l`
> 	2. `right_index`: the last index in `B` where `B[right_index] <= r`
> 3. The count of elements in B that fall within the range `[l, r]` is `right_index - left_index + 1`.
> 
> **Time Complexity:**
> - Sorting B takes O(n log n).
> - Each binary search takes O(log n), and we perform it for each of the m intervals in D, resulting in O(m log n).
> - Since m = n, the overall time complexity is O(n log n).
> 
> ```python
> def count_elements_in_ranges(B, D):
>     import bisect
> 
>     # Step 1: Sort array B
>     B.sort()
>     result = []
> 
>     # Step 2: For each range interval D[i] = [l, r]
>     for (l, r) in D:
>         # Find the leftmost index where B[i] >= l
>         left_index = bisect.bisect_left(B, l)
>         # Find the rightmost index where B[i] <= r
>         right_index = bisect.bisect_right(B, r) - 1
> 
>         # Step 3: Calculate the count of elements in the range [l, r]
>         if left_index <= right_index:
>             count = right_index - left_index + 1
>         else:
>             count = 0
> 
>         result.append(count)
> 
>     return result
> ```

## Solution

After sorting, each element `i` is in increasing order of distances from the start.

The distance $B[i+1] - B[i] > 0$ is the absolute difference between the $i$th and $(i+1)$th elements. 

For the pair `(l, r)`, if we consider the difference `r-l`, then

- if `r-l = 0` then problem reduces to finding the first element at `l = r` (one binary search)
- if `r-l < 0` then the interval is invalid, since `l > r`  so return 0
- if `r-l > 0` then this is the count of elements `r-l` distance to the **right** of the last index $i$ where $B[i] \geq l$, or `|r-l|` distance to the **left** of the first index with $B[i] \geq l$.


```
Buildings = [7, 4, 6, 2, 8]
Sorted Buildings = [2, 4, 6, 7, 8]

Deliveries = [(1, 3), (5, 5), (1, 9), (8, 8), (2, 6)]


Given (l, r) 
Sorted_Buildings = [**2**, 4, 6, 7, 8]   Reverse_Buildings = [8, 7, 6, 4, 2]

Let D(l, r) = absolute difference between (l, r)

Fix the right bound: find rightmost building j where B[j] <= r
If B[j] = l then return 1
Else  ....
```