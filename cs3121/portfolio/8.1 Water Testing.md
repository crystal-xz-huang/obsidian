## Flow Algorithms

---

When we prove the correctness of flow algorithms, we need to do two things:

- We need to show that every feasible solution is a valid flow in our network.
	- Often, this is done by construction, and is the easier direction of the proof.
- We also need to show that if a flow is maximum, the solution to the original problem is optimal.
	- Usually, we do this by showing that a valid flow corresponds to some valid solution (usually with some measurable quantity).
	- Then, maximising the flow maximises said quantity; if it did not maximise this quantity, then this would contradict the fact that the flow algorithms in lectures yield a maximum flow.

---

Suppose that we did not prove that every feasible solution is a valid flow in our network. 
1. If a feasible solution cannot be modelled by our flow network, then it's possible we have not correctly represented the constraints of the original problem.
2. If a feasible solution cannot be modelled by our flow network, then it's possible that an unmodelled solution is more optimal.

Suppose that we did not prove that a valid flow corresponds to some valid solution. 
1. The solution found by finding the max flow in the flow network might violate some of the problem constraints.  
2. We have not shown how to transform a flow back into any solution.  
3. We have not explicitly supplied a solution to the original problem.

---

## Example: Water Testing

Brooke is a marketing officer at Sydney Water, who has recently developed a water tasting experience to bring tourists to the city. She has prepared samples of $m$ waters for $n$ visitors. Following a successful advertising campaign, there is very high demand for certain waters, and visitors will be happy if they can taste one of their preferred waters, or sad if all their preferred waters are out of stock.

To address this problem, Brooke has decided to implement a system to maximise happiness (and minimise sadness). Each of the $n$ visitors will complete a survey, asking them whether each water is acceptable to them or not. Then, she will try to assign each visitor with one of their acceptable waters. Brooke wants to know the maximum number of visitors who can be made happy.

More formally, there are $n$ visitors and $m$ waters. There is an $n \times m$ boolean array, in which $A[i][j]$ is true if visitor $i$ finds water $j$ acceptable or false otherwise. Each water $j$ also has an associated quantity $q_j$ (a positive integer), denoting the number of samples of it in stock. We want to figure out the maximum number of visitors who can be assigned one of their acceptable waters.

> [!abstract]
> Input:
> - $n$ visitors, $m$ waters
> - $n \times m$ boolean array $A[i][j]$, where $A[i][j] = \text{true}$ means visitor $i$ finds water $j$ acceptable
> - for each water $j$, a stock quantity $q_j \in \mathbb{Z}^+$
> 
> For each $1 \leq i \leq n$ and $1 \leq j \leq m$, place an edge between visitor $i$ and water $j$ if and only if $A[i][j] = \text{true}$, subject to:
> - Each visitor $i$ has at most $1$ water $j$
> - Each water $j$ has at most $q_j$ visitors

> [!definition]
> - An **assignment** refers to a single match $(i, j)$ between one visitor and one water. 
> - An **allocation** refers to a collection of all assignments.  
> 

An allocation of waters to visitors = 
A collection of visitor-water edges $\{(i, j): f(v_i \to w_i ) = 1\}$.  

### Formulation

To figure out the maximum number of visitors who can be assigned one of their acceptable waters, we can model this problem using a flow network.

![[sydney-water.svg|Flow Network|400]]

We construct a flow network with:

- a source vertex $s$ and a sink vertex $t$,
- $\bbox[6px, border: 1px solid black]{n}$ vertices $v_i$ which represent the visitors and $\bbox[6px, border: 1px solid black]{m}$ vertices $w_j$ which represent the waters,
- for each visitor $i$, an edge of capacity $\boxed{1}$ from $s$ to $v_i$ representing the number of waters to be allocated to them,
- for each visitor $i$ and water $j$, an edge of capacity $\boxed{1}$ from $v_i$ to $w_j$ if water $j$ is acceptable to visitor $i$, or no edge otherwise, representing the valid allocation of waters to visitors,
- for each water $j$, an edge of capacity $\bbox[6px, border: 1px solid black]{q_j}$ from $w_j$ to $t$ representing the quantity of samples available.

> [!hint]
> Consider:
> - Are there any restrictions on how many water samples a visitor can choose?
> - Are there any restrictions on the quantity of water samples?

---

### Proof of Correctness

Now, let's prove the correctness of this algorithm, using our notes on the first page of this quiz, and analyse the time complexity of our algorithm.

Claim. An allocation exists if and only if the maximum flow .

*$(\implies)$ A valid allocation gives a valid flow*
For each visitor $i$ that has been assigned a water $j$, we send exactly $1$ unit of flow through the path $s \to v_i \to w_j \to t$. Note that over all assignments, a visitor $i$ should appear in at most $1$ match, and a water $j$ should appear in at most $q_j$ matches. By construction, $w_j$ represents one of the visitor's preferred waters.

Since each edge $s \to v_i$ has capacity $1$, each visitor vertex can only propagate at most $1$ unit of flow. Since each edge $w_j \to t$ has capacity $q_j$, each water can only propagate at most $q_j$ units of flow.

Lastly, each path from $s$ to $t$ admits at most $1$ unit of flow since for each visitor $i$ and water $j$, the flow through $v_i \to w_j$ is at most $1$, and the flow through $w_j \to v_i$ is exactly $0$. Flow is only propagated through such a path if every edge on that path has capacity remaining at least one (i.e. the visitor was unassigned and their preferred water available in the original problem), thus preserving flow conservation.

Thus, every collection of visitor–water assignments yields a valid flow, with the capacity of the flow equal to the number of assignments of visitors to waters.

*$(\impliedby)$ A valid flow gives a valid allocation*
Then, note that for any valid flow, the capacity of the flow is the number of assignments, since each flow contains exactly $1$ edge $v_i \to w_j$ for a visitor $i$ and a preferred water $j$. However, by construction; $v_i$ propagates no more than $1$ unit of flow, so each visitor is assigned exactly $1$ water, and $w_j$ propagates no more than $q_j$ units of flow, so each water is assigned to no more than $q_j$ visitors. Therefore, we have a valid set of assignments by collecting all saturated edges $v_i \to w_j$.

Hence, the capacity of the maximum flow is equal to the maximum number of visitor–water assignments. Since Edmonds–Karp returns the capacity of the maximum flow, this proves the correctness of the algorithm.

*Time Complexity Analysis*
There are up to $nm + n + m$ edges and the value of the maximum flow is up to $n$, since each customer can get assigned at most one water, so using the $O(|E||f|)$ bound and simplifying we have that the time complexity is $O(nm \cdot n) = O(n^2 m)$.

---

As an exercise, justify to yourself why no other larger assignment exists.