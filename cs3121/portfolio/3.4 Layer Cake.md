![[COMP3121_9101-3.4.pdf#height=800]]

<hr class="dots"/>

# Solution

## Part A. Cake Ordering

> [!problem|style-4] Part A
> Choose an order for the cakes where every valid stack appears as a subsequence. Make sure the ordering is described unambiguously, and prove a brief justification for why it works.

>[!citation|no-content] A valid layer cake is a stacking of layers such that no layer is wider or longer than the layer below it.

> [!caution] Stacking Rule
> We can stack cake $i$ can top of $j$ if $l_i \leq l_j$ *and* $w_i \leq w_j$.
> i.e. the top layer must be **no longer** and **no wider** than the one below it.

The main idea is the maximise the **height** of the stack by considering all possible arrangements of the cakes and find the optimal stacking order. 

1. First sort in non-increasing order of length: $l_1 \geq l_2 \geq \cdots \geq l_n$.
2. Then, for equal lengths, sort in non-increasing order of width: $w_1 \geq w_2 \geq \cdots \geq w_n$.

> This means for cakes of equal lengths, the cake with the **larger** width appears **earlier**.

- Since no two cakes have both the same width and the same length, this order is guaranteed to be deterministic (unique)

---

Notes:
- To create a cake, we stack layers one atop another in a **bottom-to-top** order[^1], where each layer is **smaller** in dimension (length and width) that the one below it. 
	- the smaller cakes are placed on top of the stack, pushing down any larger cakes already there. 
	- this means larger cakes must come earlier (below smaller ones).
	- the first layer in the sequence forms the bottom of the cake and the last layer forms the top.
	- the order of layers in the sequence increases (from bottom to top), and the order of their dimensions (length and width) is strictly descending
- Therefore we can order the sequence of cakes from bottom-to-top; that is, the **first element** in the sequence corresponds to the **bottom layer** of the cake, and the **last element** corresponds to the **top layer**.
- Then linearly arrange (or sort?) the cakes in **descending (non-increasing)** order of dimensions, so that larger layers are always considered before smaller ones and thus appear earlier in the sequence.
- This ordering aligns with the stacking rule:
	- we can stack cake $i$ can top of $j$ if $l_i \leq l_j$ and $w_i \leq w_j$
	- since:
	- at each step, the current cake $i$ is guaranteed to be **strictly smaller** in both length and width than any previously considered cake $j$ 
		- and it follows that we can extend the stack ending at $j$ by adding $i$ after it,
	- in any sequence of cakes, the larger cake $j$ appears before the smaller cake $i$ 
	- and consequently, every valid stack appears as a subsequence of this order.?

## Part B. Cake Condition

> [!problem|style-4] Part B
> Assuming the ordering you provided in part (a), what property must a subsequence of this ordering have to form a valid layer cake?

A subsequence $1 \leq i_1 < i_2 < \cdots < i_h \leq n$ forms a valid layer cake if 

$$l_{i_1} \geq l_{i_2} \geq \cdots \geq l_{i_h} \quad \text{and}\quad w_{i_1} \geq w_{i_2} \geq \cdots \geq w_{i_h}.$$

## Part C. Cake Algorithm

> [!problem|style-4]
> 
> Now, we will design an algorithm to find the subsequence with the maximum total height that forms a valid wedding cake. This is now very similar to *longest increasing subsequence* from the lectures. As such, we will try to use a dynamic programming algorithm with a similar structure.
> 
> <b>Longest increasing subsequence:</b> Find the subsequence with the maximum *length* such that *each element is larger than the previous*.
> 
> <b>Layer cake:</b> Find the subsequence with the *maximum total height* such that your condition from part (b) holds.
> 
> Define an appropriate subproblem for this problem, and complete the algorithm by defining the recurrence, base case(s), final answer, and order of computation, and analyse the time complexity.

> [!solution]
> **Subproblems**
> 
> For each $1 ≤ i ≤ n$, let $len(i)$ be the maximum length of an increasing subsequence of $A[1..i]$ which ends with $A[i]$.
> 
> **Recurrence**
> 
> For $i > 1$,
>
> $$\text{len}(i) = 1 + \max_{\substack{j < i \\ A[j] < A[i]}} \text{len}(j)
> $$
>
> **Base case**
> 
> $\text{len}(1) = 1$
> 
> **Order of computation**
> 
> Solve subproblems in increasing order of $i$. 
> 
> **Overall answer**
> 
> The overall LIS is the best of those ending at some element, i.e., $\displaystyle \max_{1 \leq i \leq n} \text{len}(i).$
> 
> **Time complexity**
>
> $O(n)$ subproblems each taking $O(n)$, and overall answer calculated in $O(n)$ time, for a total running time of $O(n^2)$.

 Find the subsequence with the _maximum total height_ such that

 $$l_{i_1} \geq l_{i_2} \geq \cdots \geq l_{i_h} \quad \text{and}\quad w_{i_1} \geq w_{i_2} \geq \cdots \geq w_{i_h}$$

###### Setup

First sort the cakes in the ordering from [[#Part A. Cake Ordering|part (a)]]:

That is, sort by non-increasing order of lengths.
Then for cakes of equal lengths, break ties by non-increasing width. 

After part (a), you have all the cakes sorted like this:

$$(l_1, w_1) \geq (l_2, w_2) \geq \cdots \geq (l_n, w_n)$$

where for every consecutive pair of cakes $(i,j)$, if $i < j$ then cake $i$ is below (before) cake $j$.

- cake 1 is the bottom layer
- cake n is the top layer

Now we pick a _subsequence_ of these cakes which:

1. is valid by the property from [[#Part B. Cake Condition|part (b)]]
2. has the maximum total height among all valid subsequence of the first $i$ cakes 
3. ends at cake $i$

###### Subproblem 

 For each $1 ≤ i ≤ n$, let $\textsf{MaxHeight}(i)$ be the maximum total height of a valid subsequence of the first $i$ cakes that ends on cake $i$. 
 

###### Recurrence

- $\textsf{MaxHeight}[0]$ is the max height of a stack of 0 cakes so $\textsf{MaxHeight}[0] = 0$
- $\textsf{MaxHeight}[1]$  is the max height of a stack of 1 cake so $\textsf{MaxHeight}[1] = h_i$ 

Let the current index be  $i$ . We want to compute the value  $\textsf{MaxHeight}[i]$ , and all previous values  $\textsf{MaxHeight}[1], \dots, \textsf{MaxHeight}[i]$  are already known. 

Then there are two cases: 

- Include cake $i$ :
	- $\textsf{MaxHeight}[i]$ : 
- Do not include cake $i$: 
	- $\textsf{MaxHeight}[i]$: 

---

For $i > 1$,

$$
\textsf{MaxHeight}(i) = h_i + \max_{\substack{j < i \\\\ l_i \leq l_j , \;  w_i \leq w_j}} \textsf{MaxHeight}(j)
$$

---

For $i > 1$, $$
 \textsf{MaxHeight}(i) = \max\left(h_i \, , \max_{\substack{j < i \\\\ l_i \leq l_j , \;  w_i \leq w_j }} \left(\textsf{MaxHeight}(j) + h_i\right)\right)$$

---

$$ 
\textsf{MaxHeight}(i) = \max(\{\, \textsf{MaxHeight}(j) + h_i \mid  1 \leq j < i, \; l_i \leq l_j, \; w_i \leq w_j \,\} 
\cup 
\{\, h_i \,\}).
$$

---

###### Base case

> If cake $i$ cannot be be stacked on any previous cake $j$, then $\textsf{MaxHeight}(i) = h_i$. 

 $\textsf{MaxHeight}(1) = h_1$

###### Order of computation

Solve subproblems in increasing order of $i$. 

###### Final answer

The overall tallest cake is the best stack ending at some cake $i$, i.e.

$$
\textsf{MaxHeight}^\ast = \max_{1 \leq i \leq n} \textsf{MaxHeight}(i)
$$

> MaxHeight* denotes the _optimal overall_ value (the final answer): the maximum height among all stacks.

###### Time complexity

There are $n$ subproblems, and for each $i$ we may compare with up to $i-1$ previous cakes, so each subproblem takes $O(n)$ time to solve. 
Therefore, the time complexity of the algorithm is $O(n^2)$.

<hr class="dots"/>

# Notes

###### Goal

The task is to find the **maximum total height** of cakes that can be stacked.

Given a set of cake layers $\{1, 2, …, n \}$ where cake $i$ has length $l_i$ , width $w_i$ and height $h_i$.
We want to find a subset of layers (forming a stack) which:
1. (valid) Forms a **valid stack** (each layer sits on top of the one below it), and
2. (optimal) Has the **maximum possible sum of heights** among all valid stacks that can be formed using the layers from this set.

###### Stacking Order

Let's pretend that we found the best arrangement of cake layers.

Since we are building a stack upwards, we define the order of layers **bottom-to-top**.

We know that cake $i$ can sit on top of a *previous* cake $j$ iff it is bigger: $l_i \leq l_j$ and $w_i \leq w_j$.

Therefore, each layer must be **increasing in (length, width)** so that the bottom layer is the largest. Thus, our best arrangement has to be subsequence of all our cakes sorted on `(l, w)`.

Now we can give the cakes a stacking order, so we know the order of layers in a stack.

That is, a valid cake stack is a sequence of cake layers $$(i_1, \dots i_k)$$

listed from bottom-to-top, such that for every pair of consecutive layers,

$$l_{i+1} \leq l_i \quad \text{and} \quad w_{i+1} \leq w_i $$

This ensures the cake on top is not larger in either dimension than the one below it.

###### Sorting the Cakes

We can build on top of an existing stack $(\dots, i)$ if its top layer $i$ is larger than the bottom layer $j$ of another stack $(j, \dots)$.

— $(a, …, i) + (j, \dots, z) = (a, …, z)$

So if we sort the sequence of all cakes on increasing `(l, w)`, then we can treat valid stacks as subsequences. Now we can give the set of cakes an order: 

- Cakes are in **non-increasing length** order (longest length appears earlier), and 
- For cakes with the same length, sort by **non-increasing width** (longest width earlier) to break ties on equal lengths. 

After sorting, every valid stack (bottom-to-top) appears as a subsequence of a sorted sequence.

So the problem becomes: 

Given a sequence of cakes ${1, 2, …, n}$ such that $l_1 \geq l_2 \geq \cdots \geq l_k \; \text{and}\; w_1 \geq w_2 \geq \cdots \geq w_k$ 
(i.e. sort the cakes first). 

Find the **tallest** subsequence of cake layers from

$$(i_1, \dots i_k)$$

such that

 $$i_1 < i_2 < \dots < i_k, \quad l_1 \geq l_2 \geq \cdots \geq l_k \quad \text{and}\quad w_1 \geq w_2 \geq \cdots \geq w_k$$

###### Developing the recursive solution

This problem is a 2D version of the [[Longest Increasing Subsequence|Longest Increasing Subsequence (LIS) problem]]. 

- Instead of comparing one number, we compare two attributes: $l_i$ and $w_i$ 
- Instead of maximising _length of the subsequence_, we maximize _total height_.

> Find the longest increasing sequence `seq` such that the **values** in `seq[i+1]` are **greater than** the corresponding values in `seq[i]` (this means `seq[i]` can be stacked on top of `seq[i+1]`).

Define a subproblem that captures the “best answer up to this point”.

Let $A[1..i]$ be an increasing sequence sorted by length and width which ends at cake $i$.

> Let `dp[i]` be the **maximum height** of a valid stack (increasing subsequence of $A[1..i]$) that ends at cake $i$ (i.e. cake $i$ is the top of the stack).

For $i > 1$, 

$$\text{dp}(i) = 1 + \max_{\substack{j < i \\ w_j \geq w_i, \; l_j \geq l_i}} \text{dp}(j)
> $$




# Resources & Further Reading

- [Box Stacking Problem - GeeksforGeeks](https://www.geeksforgeeks.org/dsa/box-stacking-problem-dp-22/)
- [Russian Doll Envelopes - LeetCode](https://leetcode.com/problems/russian-doll-envelopes/description/)

[^1]: This is the order of insertion – the order in which we arrange or stack cakes. So bottom-to-top means for a sequence of layers, the bottom layer is first and the top layer is last. Therefore, this is also the order of indices in the sequence (1, 2, ..., n) where index 1 represents the bottom layer and index n represent the top layer.
