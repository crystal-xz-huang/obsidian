# 7.3 \[PS\] Delivering Pizzas

![[COMP3121_9101-7.3.pdf#height=700]]

Design an algorithm that runs in $O(n \log n)$ time and determines the number of pizzas you need to bring on each day.

> [!abstraction]
> Given an integer array B of size n
> Find the elements in B that fall in a given interval (l, r)

![[delivering-pizzas.excalidraw.png]]


First sort the buildings in O(n log n) time
2 binary searches to locate the **boundary indices** of the elements that lie in `[l, r]`.
Find the index of the first element $\geq$ `l`
Find the index of the first element $>$ `r` (or $\leq)$ `r`

- Left boundary $i$: smallest index $i$ with $B[i] \geq l$.
	- binary search the first index with $B[i] \geq l$.
- Right boundary $j$: largest index $j$ with $B[j] \leq r$.
	- binary search the last index with $B[i] \geq l$.

If $i > j$ there are no elements in the interval.
Otherwise, the answer is $j - i + 1$.

> [!abstract]
> **Problem:**
> Given two integer arrays `B` and `D`, each of size `n`.
> Each element `D[i]` contains a pair `(l, r)` representing a range interval `[l, r]`.
> Find the number of elements in B that fall within each range interval `D[i]`.
> 
> **Divide and conquer approach:**
> 1. Sort array B: `O(n log n)`
> 2. For each range interval `D[i] = [l, r]`, use binary search to find:
> 	1. `left_index`: the first index in `B` where `B[left_index] >= l`
> 	2. `right_index`: the last index in `B` where `B[right_index] <= r`
> 3. The count of elements in B that fall within the range `[l, r]` is `right_index - left_index + 1`.
> 
> **Time Complexity:**
> - Sorting B takes O(n log n).
> - Each binary search takes O(log n), and we perform it for each of the m intervals in D, resulting in O(m log n).
> - Since m = n, the overall time complexity is O(n log n).
> 
> ```python
> def count_elements_in_ranges(B, D):
>     import bisect
> 
>     # Step 1: Sort array B
>     B.sort()
>     result = []
> 
>     # Step 2: For each range interval D[i] = [l, r]
>     for (l, r) in D:
>         # Find the leftmost index where B[i] >= l
>         left_index = bisect.bisect_left(B, l)
>         # Find the rightmost index where B[i] <= r
>         right_index = bisect.bisect_right(B, r) - 1
> 
>         # Step 3: Calculate the count of elements in the range [l, r]
>         if left_index <= right_index:
>             count = right_index - left_index + 1
>         else:
>             count = 0
> 
>         result.append(count)
> 
>     return result
> ```


# References & Further Reading

- [How to find array elements that fall in a given interval?](https://stackoverflow.com/questions/14913556/how-to-find-array-elements-that-fall-in-a-given-interval?rq=3)