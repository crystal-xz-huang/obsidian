# 4.4 \[PS\] Slide To The Bottom Right

![[COMP3121_9101-4.4.pdf#height=800]]

## Problem Description

> [!problem]
> Suppose we have a grid $G$ with $n$ rows and $m$ columns and a set $S$ of points in this grid. 
> 
> A path is *valid* if it starts from the top-leftmost point $(1,1)$ and finishes at the bottom-rightmost point $(m,n)$, and the only moves are to step one unit to the right or one unit down.
> 
> A path is *unblocked* if it is both valid and does not go through any points in $S$  
> 
> Design and analyse an efficient algorithm that outputs the number of unblocked paths.

- Given a $n  \times m$ grid $G$ with $m$ columns ($x$-axis) and $n$ rows ($y$-axis)
- Each point $(x, y)$ of the grid is indexed by $1 \leq x \leq m$ and $1 \leq y \leq n$.  
- $S \subseteq \{1, …, n \} \times  \{1, …, m\}$ of points (vertices) that are **blocked**.
- From any point you can only move in two directions:
	- from $(x,y)$ to $(x+1,y)$ (right), and 
	- from $(x,y)$ to $(x,y+1)$ (down) when those cells exist and are not in $S$
- <b>Task:</b> Count the number of ways to get to from $(1,1)$ to $(m,n)$, using only rightwards and downwards moves.

###### Abstraction

- **Vertices**: Each vertex $(x,y)$ is a grid point at column $1 \leq x \leq m$ and row $1 \leq y \leq n$ 
- **Directed edges**: From each vertex we can only move in two directions:
	- $(x,y) \to (x,y+1)$ (down)
	- $(x,y) \to (x+1,y)$ (right) 
	- when those cells exist and aren’t in $S$
	- note that each move either increases $i$ or $j$ 
- A path is valid if it starts from $(1, 1)$ and finishes at $(m, n)$
- A path is unblocked if for $p_1, p_2, \ldots, p_n$ we have $p_i \notin S$ 
- Model $G$ as [[Directed Acyclic Graphs and Topological Ordering|directed acyclic graph (DAG)]]:
	- **vertices**: all cells ***not*** in $S$;  
	- **topological ordering** = process cells in increasing order of $(x+y)$

<b>Task:</b> Count the number of $s \to t$ paths from $s=(1,1)$ to $t=(m, n)$ in a DAG. 

> [!question] Why is it a DAG?
> - Every edge strictly increases $x+y$ and you can't loop back.
> - Directed: strictly one-way: you can go right or down 

###### Recurrence

> A point is blocked if $(x,y) \in S$.
> Consider the case when $(1, 1) \in S$. How many paths are there in that case? 

Consider each grid point $(x,y)$ with $1 \le x \le m$ (column) and $1 \le y \le n$ (row).

To end at point $(x,y)$, it must be unblocked and you can either come from the **left** $(x-1,y)$ or from **above** $(x,y-1)$.

![[slide-to-the-bottom-right-graph.excalidraw.png|400]]

**Subproblems**
For each $1 \le x \le m$ and $1 \le y \leq n$, let $\mathsf{GridSlide}(x,y)$ denote the number of *unblocked* paths from $(1, 1)$ to $(x,y)$ where we can only move right and down. 

**Steps**
1. If $(x,y) \in S$ then the cell is **blocked**. There are no paths to a blocked cell.

    $$\mathsf{GridSlide}(x,y) = 0 \quad \text{if } (x,y) \in S$$

2. If $(x,y) \notin S$ then the cell is **not blocked**. 
	1. If $x=1$ then we are in the **first column** ⇒ can only come from above 

		$$\mathsf{GridSlide}(1,y) = \mathsf{GridSlide}(1,y-1) \quad \text{if } (x,y) \notin S \text{ and } x=1$$

	2. If $y=1$ then we are in the **first row** ⇒ can only come from the left

	   $$\mathsf{GridSlide}(x,1) = \mathsf{GridSlide}(x-1, 1) \quad \text{if } (x,y) \notin S \text{ and } y=1$$

	3. Otherwise $x > 1, y > 1$ and we can come from the left or from above:

	   $$\mathsf{GridSlide}(x,y) = \mathsf{GridSlide}(x-1,y) + \mathsf{GridSlide}(x,y-1)\quad \text{if } (x,y) \notin S \text{ and } 1 < x,y$$

**Basis**
If $x=1,y=1$ then we are at the start.
- If $(1,1)\in S$ the starting point is blocked. 

  $$\mathsf{GridSlide}(1,1) = 0  \quad \text{if } (x,y) \in S \text{ and }x=1, y=1$$

- If $(1,1)\notin S$ there is only one path that ends at $(1,1)$ i.e., $(1,1) \to (1,1)$.

  $$\mathsf{GridSlide}(1,1) = 1  \quad \text{if } (x,y) \notin S \text{ and }x=1, y=1$$


Recurrence
For each $1 \le x \le m$ and $1 \le y \leq n$, let $\mathsf{GridSlide}(x,y)$ denote the number of *unblocked* paths from $(1, 1)$ to $(x,y)$ where we can only move right and down. The recurrence is given by

$$
\mathsf{GridSlide}(x,y) =  
\begin{cases}  
0  & \text{if } (x, y) \in S, \\[4pt]  
\mathsf{GridSlide}(x,y - 1) & \text{if } x = 1,\\[4pt]  
\mathsf{GridSlide}(x - 1, 1) & \text{if } y = 1,\\[4pt]  
\mathsf{GridSlide}(x,y - 1) + \mathsf{GridSlide}(x - 1,y) & \text{otherwise.}  
\end{cases}
$$

The base case is $\text{GridSlide}(1, 1) = 1$ with the final solution being $\text{GridSlide}(m, n)$. We fill the dynamic programming table in increasing order of $x$, followed by increasing order of $y$.


###### Dependencies

In order to compute $\mathsf{GridSlide}(x,y)$, we must have already solved for $\mathsf{GridSlide}(x,y - 1)$ (entry above) and $\mathsf{GridSlide}(x - 1,y)$ (entry below). 

Therefore, we should solve in increasing order of $x$, then increasing order of $y$.

###### Analysis

There are $O(mn)$ subproblems and each subproblem takes $O(1)$ time to solve. Therefore, the overall time complexity of the algorithm is $O(mn)$.



### Remarks

- With no blocked cells ($S=\varnothing$), the answer is the binomial coefficient $\binom{n+m-2}{n-1}$ (choose which $(n-1)$ of the $(n+m-2)$ moves are downs). DP collapses to that.  
- Edge cases: if an entire first row prefix or first column prefix hits a blocked cell, everything beyond it in that line becomes $0$ by the base cases.  

---

## Examples

### GridPaths

Houses in the country of DynaProg are positioned on an $m \times n$ grid with the top left house positioned at $(1, 1)$ and the bottom right house positioned at $(m, n)$. You live in the top left house and you need to get to your friend’s house which is positioned in the bottom right, but you walk such that you’re always making progress towards their house (i.e. you can only walk down or to the right).

Design an $O(mn)$ algorithm that counts the number of ways to get from your house to your friend’s house, moving in only two directions.

**Solution.** 
For each $1 \le x,y \le n$, let $\mathsf{GridPath}(x,y)$ denote the number of ways to start from $(1, 1)$ and finish at cell $(x,y)$ where we can only move right and down. The recurrence is given by

$$
\mathsf{GridPath}(x,y) =  
\begin{cases}  
\mathsf{GridPath}(x,y - 1) & \text{if } i = 1,\\[4pt]  
\mathsf{GridPath}(i - 1, j) & \text{if } j = 1,\\[4pt]  
\mathsf{GridPath}(x,y - 1) + \mathsf{GridPath}(i - 1, j) & \text{otherwise.}  
\end{cases}
$$

The base case is $\text{GridPath}(1, 1) = 1$ with the final solution being $\text{GridPath}(m, n)$. We fill the dynamic programming table in increasing order of $i$, followed by increasing order of $j$.

**Correctness.** As an exercise, try and argue its correctness. If we finish at cell $(x,y)$, note that we could have come from cell $(i - 1, j)$ by moving right or from cell $(x,y - 1)$ by moving down. Then use your inductive hypothesis (what does that look like here?) to argue that the recurrence is correct.

**Time complexity.** There are $O(mn)$ subproblems and each subproblem can be solved in $O(1)$ time. Therefore, the dynamic programming algorithm runs in $O(mn)$ time.

---

Suppose $G$ is a directed, acyclic graph (DAG) with at least two vertices and is connected in the undirected sense (for example, ABEFG are connected and CD are connected). Define S ⊆ V as the set of source nodes: those vertices with no incoming edges and T ⊆ V as the set of sink nodes: those vertices with no outgoing edges. Prove that the minimum number of links which have to be added is max(|S|, |T |).

Note that each source vertex must have at least one incoming edge added, and each sink vertex must have at least one outgoing edge added. Hence, we have a lower bound of max(|S|, |T |). To achieve this, assume without loss of generality that |S| ≥ |T | (there are more sources than sinks). Add one edge to each source from some sink, making sure that each sink gets at least one outgoing edge and each source gets exactly one incoming edge.

Since in the original graph there is a path from each source to each sink, adding all such edges implies that there is a path from any sink u ∈ T to any other sink v ∈ T and hence (by construction) to any source w ∈ S. Therefore, there is a path from every sink to every other node in the graph. Then, since from every node in the graph there is a path to a sink, this implies that there is a path from every node to every other node.